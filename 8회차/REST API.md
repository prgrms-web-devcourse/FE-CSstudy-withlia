# REST API

**REST** ( **REpresentational State Transfer ) 은 2000년에 로이 펄딩의 논문에서 소개되었음.**

이는 HTTP의 장점을 최대한 활용하기 위해 소개 되엇다.

### 그래서 무엇을 위한 것인데?

**REST는 HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식**을 규정한 아키텍쳐이다.

> REST를 잘 지킨 것을 RESTful 하다고 한다.

### 그래서 왜 쓰게 되었는데?

1. 프론트와 백엔드의 분리
   - 프론트 단에서 데이터를 보여주기 위해 백엔드 단으로부터 데이터를 요청하고 가져와야 하는데, **RequestMethod ( HTTP: GET, POST, PUT, DELETE )와 URL을 이용해서 가져와야 했습니다.**
2. 멀티 플렛폼에 대한 대응
   - 웹 + 모바일 웹
   - 아이폰, 안드로이드

## REST API의 구성

---

1. 자원
   - 자원은 말 그대로 데이터를 의미한다.
2. 행위
   - 행위는 자원을 어떻게 활용할 것인지에 대한 정의를 내리게 된다.
3. 표현
   - 표현은 위에서 언근된 행위를 구체적으로 어떤 내용으로 요청할 것인지?
   - 이에 대한 표현은 **페이로드로 처리**

## REST API 설계 원칙

---

1. URL은 리소스를 표현하는데 집중한다.
2. 행위에 대한 정의는 HTTP 요청 메소드를 사용해야 한다.

### URL은 리소스를 표현하는데 집중한다.

```jsx
# bad
GET /getTodos/1
GET /totos/show/1

#good
GET /todos/1
```

- 리소스는 `URI`로 표현되는데 리소스가 가리키는 것은 `명사`로 표현되어야 한다.
- 행위는 `HTTP Method`로 표현하고, `GET(조회)`, `POST(생성)`, `PUT(기존 entity 전체 수정)`, `PATCH(기존 entity 일부 수정)`, `DELETE(삭제)`을 분명한 목적으로 사용한다.

### 행위에 대한 정의는 HTTP 요청 메소드를 사용한다.

**HTTP 요청 메소드는 서버에게 나는 어떻게 무엇을 원한다!** 라고 알려주는 역할이다.

식당의 예로 들어보면 클라이언트 즉, 손님이 어떠한 주방장 즉, 서버에게 다음과 같은 요청을 하는 것이다.

- 음식 추가
- 주문
- 주문 추가
- 주문 취소

즉, 클라이언트가 서버에게 어떠한 행위 즉, 요청을 할 때 다음과 같은 HTTP 요청 메서드에 의해 요청을 해야 한다.

![스크린샷 2021-08-13 오후 1.56.00.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/dad24067-6e40-4019-bb47-f48241a99f7b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-08-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.56.00.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220923%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220923T120016Z&X-Amz-Expires=86400&X-Amz-Signature=72497d253a2edf4d3e4e22a61d6674ffa5bcb531bd96d55e0b4590841927050a&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%25202021-08-13%2520%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%25201.56.00.png%22&x-id=GetObject)

**리소스에 대한 행위는 HTTP 요청 메서드를 통해 표현하게 되고, URI에 표현하지 않습니다.**

```jsx
# bad
GET /todos/delete/1

# good
DELETE /todos/1
```

## 4. HTTP 메서드 속성

---

![스크린샷 2022-04-18 오전 10.45.59.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/1be0022f-0412-4736-a38b-88df59e4ee18/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-18_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.45.59.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220923%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220923T120039Z&X-Amz-Expires=86400&X-Amz-Signature=8559cdaa6434ff2c1db6e59e752a994e337f5d5e308bdd0fe5d3ac8a52483799&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%25202022-04-18%2520%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB%252010.45.59.png%22&x-id=GetObject)

## 안전

- 호출해도 리소스를 변경하지 않는다.
  - GET → 리소스를 읽어오는 것이기 때문에 안전.
  - POST → 리소스를 변경하는 것.
  - 리소스를 변경하는 것은 안전하지 않다고 말한다.
- 그래도 계속 호출하여, 로그가 쌓여 장애가 발생하는 것은..?
  - GET을 계속 호출하여 장애가 발생하는 경우?
- 안전은 해당 리소스만 고려한다.
  - 즉, 안전은 리소스가 변경되는지 되지 않는지만 고려한다!

## 멱등

- **한 번 호출하든 두 번 호출하든 100번 호출하든 결과는 같다..**
- **멱등 메서드**
  - GET → 한 번 조회하든, 두 번 조회하든 **같은 결과가 조회**됨..
  - PUT → 결과를 대체한다. 따라서, 같은 요청을 여러번 해도 최종 결과는 같다.
    - **기존 것을 날리고 내 것으로 덮어버리기 때문에 멱등**이라 할 수 있다.
  - DELETE → 결과를 삭제한다. **같은 요청을 여러번 해도 삭제된 결과는 같다**.
  - POST → 멱등이 아니다! 두 번 호출하면 같은 결제가 중복해서 발생할 수 있다.
    - 두 번결제하면 멱등이다.
    - 그러니까, **POST는 계속 새롭게 생성하므로 결과가 달라질 수 있다.**

### **활용**

- 자동 복구 메커니즘
  - 예를 들어 DELETE
    - 삭제 요청을 날리면 삭제된 결과는 같음. 따라서, 만약 삭제에 대한 응답이 돌아오지 않았다면 다시 삭제 요청을 날려도 됨.. ( 삭제된 결과는 같으니.. )
- 서버가 **TIMEOUT 등으로 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도 되는가?**

### **재요청 중간에 다른 곳에서 리소스를 변경해버리면..?**

- 사용자 1 → GET ( username: A, age: 20 )
- 사용자 2 → PUT ( username: A, **age: 30** )
- 사용자 1 → GET ( username: A, age: 30 )

이와 같이, 다른 사용자가 리소스를 바꿨다면 이또한 멱등이라 볼 수 있다.

이유는 **외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않는다.**

## 캐시 가능

- 응답 결과 리소스를 캐시해서 사용해도 되는가?
  - 무거운 파일을 요청한다고 했을때, 이후에 같은 요청에 대해 기억하고 있다면 새로 불러오는 로직 필요없이 기억한 것을 반환하면 된다.
- GET, HEAD, PATCH 캐시 가능
- **실제로 GET, HEAD 정도만 사용**
  - POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않다.
  - 따라서, 실무에서는 거의 GET만 캐시로 사용된다.

## REST 특징 ( USCSCL )

---

### 1. Uniform (유니폼 인터페이스)

- HTTP 표준안만 따르면, 안드로이드 / IOS 플랫폼이든, 특정 언어나 기술에 종속 되지 않는 플랫폼에 사용할 수 있다.

### 2. Stateless (무상태성)

- REST는 무상태성 즉, 상태정보를 따로 관리하고 있지 않기 때문에, 단순히 요청만 처리하면 된되어, 서버에 불필요한 정보를 관리하지 않아, 구현이 단순해집니다.

### 3. Cacheable (캐시 가능)

- REST는 HTTP 표준을 그대로 따르기 때문에 캐싱 기능 적용이 가능합니다.
- Last-Modified태그 또는 E-Tag를 이용하면 가능합니다.

### 4. Self-descriptiveness (자체 표현 구조)

- 메시지만 보고도 쉽게 이해할 수 있는 구조를 가지고 있다.

### 5. Client - Server 구조

- 자원이 있는 쪽이 Server, 자원을 요청하는 쪽이 Client가 된다.
  - REST Server → API를 제공하고 비즈니스 로직 처리 및 저장을 책임진다.
  - Client → 사용자 인증, context( 세션, 로그인 정보 )를 직접 관리 및 책임진다.

⇒ 서로간의 의존성이 줄어든다.

### 6. Layered System ( 계층화 )

- Client는 REST API Server만 호출한다.
- REST Server는 다중 계층으로 구성될 수 있다.
  - API Server는 순수 비즈니스 로직을 수행하고 보안, 로드밸런싱 등등 여러가지 계층을 둘 수 있다.
