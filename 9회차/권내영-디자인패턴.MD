# 디자인 패턴

프로그램을 설계할 때 발생했던 문제점들을 해결할 수 있도록 하나의 `규약` 형태로 만들어 놓은 것을 의미한다.

### 디자인 패턴을 사용하는 이유

소프트웨어 개발을 할 때에 개발자들이 자신의 방식대로 코드를 짜는 것보다 규칙성, 효율성을 생각하며 짜야 한다.

디자인 패턴은 소프트웨어 엔지니어들이 올바른 설계를 빠르게 만들 수 있게 해주고, 또 반복적으로 일어날 수 있는 문제들을 예방하거나 빠르게 해결할 수 있는 방법을 제시해 준다.

## MVC 패턴

MVC 패턴은 **모델(Model), 뷰(View), 컨트롤러(Controller)**로 이루어진 디자인 패턴이다.

애플리케이션의 구성 요소를 세 가지 역할로 구분해 **개발 프로세스에서 각각의 구성 요소에만 집중**해 개발할 수 있다.

- **모델(Model)**

**애플리케이션의 정보, 데이터**를 나타낸다.

- 사용자가 편집하길 원하는 **모든 데이터**를 가지고 있어야 한다.
- 뷰나 컨트롤러에 대해서 어떤 정보도 몰라야 한다.

- **뷰(View)**

사용자에게 보여지는 부분, 즉 **유저 인터페이스**를 의미한다.

- 모델이 가지고 있는 정보를 따로 저장하지 않아야 한다.
- 모델과 컨트롤러와 같이 다른 구성 요소들을 몰라야 한다.

- **컨트롤러(Controller)**

하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 **메인 로직**을 담당한다.

- **뷰 - 모델** 사이를 중재하기 위해 모델과 뷰를 알고 있어야 한다.
- **모델**이나 **뷰의 변경**을 모니터링 해야 한다.

![KakaoTalk_20221002_150812292](https://user-images.githubusercontent.com/75849590/193604319-8d869ac1-4ef8-43dc-8cf4-e3e7a8c9626e.jpg)

### MVC 패턴 사용 시 일반적인 흐름

- 사용자가 요청을 보내면 해당 요청을 **Controller**가 받는다.
- Controller는 Model을 통해 데이터를 가져오고, 해당 데이터를 바탕으로 출력을 담당하는 View를 제어해서 사용자에게 전달한다.



- **백엔드에서의 일반적인 수행 절차**

1. client의 request를 받는다.
2. request를 분석한다
3. 필요한 데이터를 수집 / 가공한다
4. 뷰를 생성하고 response 한다.


### **장점**

- 기능별로 코드를 분리하여 하나의 파일에 코드가 모이는 것을 방지하여 가독성과 코드의 재사용이 증가한다.
- 각 구성요소들을 독립시켜 협업을 할 때 맡은 부분의 개발에만 집중할 수 있어 개발의 효율성을 높여준다. 분업이 가능하다.
- • 개발 후에도 유지보수성과 확장성이 보장된다.

### 단점

- 애플리케이션이 복잡해질수록 모델 - 뷰 와의 관계가 복잡해진다

Model과 View는 서로의 정보를 갖고 있지 않는 독립적인 상태라고 하지만 Model과 View사이에는 Controller를 통해 소통을 이루기에 의존성이 완전히 분리될 수 없습니다.

### 프론트엔드에서의 MVC 패턴



- **view의 복잡성 증가**

FE는 그 자체가 view다. 보통 MVC에서 View는 만들어지는 결정체인 것과 달리, FE의 view는 이벤트 발생 등 컨트롤러와 같은 일을 하기도 한다. 따라서 이벤트 발생이 매우 다양하다.

ex) 사용자 입력값, 화면 선택, 변경, 스케줄, 서버와 통신 등,,,

또한 View의 변경으로 Model을 변경해야 하는 경우 또는, Model의 변경으로 view를 변경해야 하는 경우가 있다.

- **매우 많은 view와 Model**

애초에 FE에서의 view는 하나가 아닌 여러개이이다.
![KakaoTalk_20221002_152415441](https://user-images.githubusercontent.com/75849590/193604724-54fb9d1e-b919-4696-98c8-d5d67a799ce5.jpg)
![KakaoTalk_20221002_152449929](https://user-images.githubusercontent.com/75849590/193604734-e4980106-56a0-4e25-9c3e-2b42ff01b22a.jpg)


다수의 View와 Model이 Controller를 통해 연결되기 때문에 이런 식으로 컨트롤러가 비대해지는 **Massive-View-Controller** 부작용이 일어나게 된다.

- **계층 구조를 가지고 있는 view**

View는 DOM을 나타낸 것이기 때문에, 트리 구조로 잘게 쪼개진다. 계층 구조를 가지게 되는 것이다.

FE에서는 DOM만큼은 아니지만 어느정도 계층적인 구조를 만들면서 렌더링 효율성을 만들어야 한다.

## React의 Flux 아키텍처

MVC에서의 양방향 흐름과 달리, flux 아키텍처는 한 방향으로 흐름을 제어하면서 동작하도록 한다.


- **Action(Action Creator)**

이벤트가 발생했을 때, 그 이벤트의 Action 정보를 가지고 있는 객체(type과 payload)를 만들어서 Dispatcher에 전달한다.

```jsx
{
	type : UPDATE_MATH
	payload : {
		id : 1,
		score : 95,
	}
}
```

- **Dispatcher**

Action 객체 정보를 받아서 Store로 넘기는 `중앙 허브`의 역할을 한다.

주로 `switch` 문으로 들어오는 Action 객체를 나눠 처리한다. Action 객체의 `type` 을 구분해 미리 작성해둔 명령을 수행한다. 데이터 변동이 있을 때 실행될 콜백을 가지고 있다.

- 콜백은 이벤트를 개별적으로 구독하지 않는다. 모든 데이터 변동은 등록된 모든 콜백에 전달된다.
- 콜백이 실행될 때 콜백의 전체나 일부를 중단할 수 있다.

액션을 보낼 수 있는 모든 Store을 가지고 있고, 액션 생성자로부터 액션이 넘어오면 스토어들에게 액션을 보낸다. 이때 Store가 서로를 의존하고 있다면, 특정 스토어가 업데이트되기를 기다리게 해주는 waitFor을 사용할 수 있다.

- **Store**

어플리케이션의 데이터, 상태와 상태 변경 메서드를 가지고 있다.

Store를 Dispatcher와 연결해 Store에 접근할 수 있도록 callback 명령을 제공한다.

스토어에 상태 변경을 완료하면 View에 상태 변경 사항을 알려준다.

- **View**

Store에서 어떤 이벤트가 발생하면 View는 변경된 점을 가져오고, 이를 바탕으로 유저에게 뵤여줄 화면을 다시 렌더링한다.

### **일반적인 흐름 예시**

- 선생님이 뷰를 통해 A의 수학 점수를 입력한다.
- 뷰는 데이터를 업데이트하기 위해 액션 생성자를 호출한다.
- 액션 생성자는 수학 점수를 업데이트하기 위한 액션 타입과 입력된 값을 묶어 디스패쳐로 전달한다.
- (예: `type: 'UPDATE_MATH', payload: '95'`)
- 액션 메시지를 감지한 디스패쳐는 액션을 `mathStore`와 `studentStore`에 전달한다.
- 각 스토어는 액션 타입에 따라 상태를 변경한다. 만일 `studentStore`가 `mathStore`를 의존하고 있다면,  `mathStore`가 먼저 업데이트되기를 기다렸다가 `studentStore`를 업데이트할 수 있다.
- 스토어가 업데이트를 마치면 이를 감지한 컨트롤러 뷰가 자식 뷰에게 새로운 값을 분배한다.
- 마지막으로 뷰는 새로운 값으로 화면을 렌더링한다.

대부분의 상태 관리 라이브러리는 Flux 아키텍처를 따르거나, Store가 바뀌면 View를 자동으로 렌더링해준다는 개념을 바탕으로 만든다.

## Vue의 MVVM 패턴

mvvm 패턴은 MVC의 C에 해당하는 컨트롤러가 뷰 모델로 바뀐 패턴이다.

### 양방향 데이터 바인딩

view ↔ model 자동 변경

데이터가 바뀌면 자동으로 view 바뀜

view가 바뀌면 model이 자동 변경

VM ⇒ view model

뷰에서 쓰이는 모델을 가지고 있다가 뷰의 변경사항이 생기면 vm 업데이트, vm이 바뀌면 view로 업데이트시키는 것이다.

MVVM 패턴은 MVC패턴과는 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징이다. 뷰와 뷰 모델 사이의 양방향 데이터 바인딩을 지원하며 ui를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉽다.

