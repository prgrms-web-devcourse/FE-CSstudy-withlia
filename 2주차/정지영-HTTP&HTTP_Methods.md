# HTTP 프로토콜, HTTP 프로토콜 methods

> 💡 정리된 내용은 HTTP 1.1을 다룹니다

<details>
<summary>☑ 목차</summary>

0. [프로토콜이란?](#⓿-프로토콜이란)
1. [HTTP 프로토콜이란?](#❶-http-프로토콜이란)

   1-1. [HTTP 작동 방식](#①-http-작동-방식)

   1-2. [HTTP 특성](#②-http-특성)

2. [요청/응답 메세지](#❷-요청응답-메세지)

   2-1. [요청 메세지 포맷](#①-요청-메세지-포맷)

   2-2. [응답 메세지 포맷](#②-응답-메세지-포맷)

   2-3. [헤더](#③-헤더)

   2-4. [keep-alive](#④-keep-alive)

   2-5. [상태 코드](#⑤-상태-코드)

3. [http 인증 방법](#❸-http-인증-방법)
4. [HTTP Method](#❹-http-method)

   4-1. [HTTP의 GET과 POST](#①-http의-get과-post)
   </details>

<br><br><br>

# ⓿ 프로토콜이란?

**사람과 사람이 대화할 때 서로 이해할 수 있는 언어, 공용 언어를 사용하여 전세계 모든 사람과 대화할 수 있다**라고 하면

컴퓨터와 컴퓨터도 **서로 이해할 수 있는 언어, 공용된 언어**를 사용해야합니다.

<br>

**프로토콜**

> 💡 컴퓨터나 네트워크 장비가 서로 통신하기 위해 미리 정해놓은 약속, 규약을 뜻합니다.

<br><br><br>

# ❶ HTTP 프로토콜이란?

**HyperText**(참조 즉 하이퍼링크를 통해 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트) 문서들을 주고받기 위한 규약으로,

쉽게 말해 인터넷(WWW 상)에서 데이터를 주고 받을 수 있는 프로토콜입니다.

- **TCP/IP**를 이용하는 응용 계층 프로토콜입니다. (실제 전송은 TCP/IP를 통해 이뤄집니다.)
- 포트: 80번

<br><br>

## ①. HTTP 작동 방식

사용자가 브라우저를 통해 어떠한 서비스를 url을 통하거나 다른 것을 통해 `요청(request)`하면

서버에서는 해당 요청 사항에 맞는 결과를 찾아 사용자에게 `응답(response)`을 전송하는 형태로 작동합니다.

- 서버-클라이언트 모델
- 클라이언트 request → 서버 response

![http 작동 방식](https://velog.velcdn.com/post-images%2Fsurim014%2Fe0aa5520-2d59-11ea-86da-fb3b00230640%2Fimage.png)

<br><br>

## ②. HTTP 특성

**Connectionless**

- 서버에 연결하고, 요청해서 응답을 받으면 연결을 끊어버립니다.
- 자원 하나에 대해서 하나의 연결만을 만듭니다.

**장점**

- 불특정 다수를 대상으로 하는 서비스에 적합합니다.
- 수십만명이 웹 서비스를 사용하더라도 접속 유지는 최소한으로 유지합니다.
- 따라서 더 많은 유저의 요청을 처리할 수 있습니다.

**단점**

- 연결을 끊어버리기 때문에 클라이언트의 이전 상태를 알 수 없습니다. **(Stateless)**
- 클라이언트가 과거에 로그인을 성공하더라도, 로그 정보를 유지할 수 없습니다.
- HTTP는 웹의 cookie나 session을 이용해서 이 문제를 해결하고 있습니다.

<br>

> **Cookie**<br>클라이언트와 서버의 상태 정보를 담고 있는 정보조각

> **예시**<br>첫 요청 시 : 클라이언트 로그인 성공 → 서버 로그인 정보를 자신의 DB에 저장 → return 쿠키 (to 클라이언트)<br>두번째 요청 시 : 클라이언트 쿠키 요청 (to 서버) → 서버는 해당 쿠키로 자신의 DB 조회 → 로그인 여부 확인

<br><br><br>

# ❷ 요청/응답 메세지

클라이언트가 서버로 보내는 요청, 서버가 클라이언트로 보내는 응답은 메세지 형식입니다.

해당 메세지의 포맷을 알아보도록 하겠습니다.

요청과 응답 데이터는 `시작줄, Header, body`로 구성되어 있습니다.

> 시작줄과 헤더를 묶어 HTTP 메세지 헤드(head), body는 메세지 본문(body)라고 부릅니다.

<br>

## ①. 요청 메세지 포맷

클라이언트가 서버에게 요청을 보낼 때 요청하는 '정보'를 담아 보냅니다.

<br>

### ▶ 요청 메세지 예시

```
	GET https://www.zerocho.com HTTP/1.1 						// 시작줄
	User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...   // 헤더
	Upgrade-Insecure-Requests: 1

	...														// 본문
```

- **시작줄**

첫 줄이 시작줄입니다. 시작줄에는 해당 정보가 포함됩니다.

1. 요청 메서드 : GET, PUT, POST, PUSH, OPTIONS 등의 요청 방식을 명시합니다.
2. 요청 URI : 요청하는 자원의 위치를 명시
3. HTTP 프로토콜 버전 : 웹 브라우저가 사용하는 프로토콜 버전 (HTTP/2.0)

<br>

- **헤더**

시작 줄의 다음 줄은 Header입니다. Header에는 요청에 대한 다양한 정보를 담습니다.

<br>

- **본문**

헤더에서 한 줄을 띄운 후 부터 본문이 시작됩니다.

본문은 요청을 할 때, 함께 보낼 필요한 데이터를 담는 부분입니다.

<br>

보통 리소스를 가져오는 요청(`GET, HEAD, DELETE...`)에는 body가 필요하지 않습니다.

주로 `POST` 요청에서 body 부분에 데이터를 넣어 보냅니다.

<br>

> ▶ 요청 메서드, 헤더에 대한 내용은 하단에서 자세히 다룹니다.

<br><br><br>

## ②. 응답 메세지 포맷

서버가 클라이언트로부터 요청을 받았을 때, 보내는 응답 포맷입니다.

<br>

### ▶ 응답 예시

```
	HTTP/1.1 200 OK											// 시작줄
	Connection: keep-alive									// 헤더
	Content-Encoding: gzip
	Content-Length: 35653
	Content-Type: text/html;

	<!DOCTYPE html><html lang="ko" data-reactroot=""><head><title... // 본문
```

- **시작줄**

시작줄에는 해당 정보가 포함됩니다.

1. 응답 프로토콜과 버전 : 응답 프로토콜인 HTTP와 버전을 명시합니다.
2. 상태 코드 : 요청이 어떤 상태로 처리되었는지 명시합니다.
3. 상태 메세지

<br>

- **헤더**

그 다음줄은 헤더입니다. 헤더에는 클라이언트에 전송할 다양한 정보가 포함되어 있습니다.

<br>

- **본문**

요청 포맷과 동일하게 헤더에서 한줄을 띄운 후 부터 본문이 시작됩니다.

해당 예시에는 응답으로 보낸 HTML 문서가 들어 있습니다.

이 HTML 문서를 받아 브라우저가 파싱한 후, 화면에 렌더링하게 됩니다.

<br><br>

## ③. 헤더

요청, 응답 메세지에는 헤더 부분이 존재합니다.

이러한 헤더에는 어떤 것들이 적혀질지 알아보겠습니다.

<br>

### ▶ 요청, 응답 공통 헤더

- **Date** : HTTP 메세지가 만들어진 시각
- **Connection** : 기본적으로 `keep-alive`의 값을 가집니다.
- **Cache-Control** : 캐싱 옵션을 지정합니다.
- **Content** : content에 대한 정보를 담아줍니다. Content-Length, Content-Type 등이 있습니다.

### ▶ 요청 헤더

- **Host** : 서버의 도메인 네임이 나타납니다. 반드시 하나가 존재해야합니다.
- **User-Agent** : 현재 사용자가 어떤 클라이언트를 이용해 요청을 보냈는지 나타냅니다.
- **Accept** : Accept 헤더는 요청을 보낼 때, 서버에서 보내줬으면 하는 데이터의 타입을 명시합니다.<br>
  요청, 응답 공통 헤더의 content와 같이 Accept-Length, Accept-Encoding 등이 있습니다.
- **Authorization** : 인증 토큰을 서버로 보낼 때 사용하는 헤더입니다.
- **Origin** : POST와 같은 요청을 보낼 때, 요청이 어느 주소에서 시작되었는지 나타냅니다.
  여기서 요청을 보낸 주소와 받는 주소가 다르면, **CORS 에러**가 나타나곤 합니다.

### ▶ 응답 헤더

- **Access-Control-Allow-Origin** : 프론트 주소를 적어줍니다.<br>
  요청을 보내는 프론트 주소와, 받는 백엔드 주소가 다르면 CORS에러가 나타납니다.<br>
  따라서 서버에서 해당 헤더를 적어주어야 에러를 방지할 수 있습니다.
- **Location**: 300번대 응답이나 201 응답일 때, 어느 페이지로 이동할지 알려줍니다.

<br>

이 외에도 많은 헤더가 존재합니다.

<br><br>

## ④ Keep Alive

요청, 응답 메세지 헤더 부분, `Connection: keep-alive`이 있습니다.

이때, keep-alive는 무엇일까요?

> 지정된 시간동안 연결을 끊지 않고 요청을 계속해서 보낼 수 있는 특징입니다.

<br>

원래 HTTP는 하나의 연결에 하나의 요청을 하는 것을 기준으로 설계되었습니다. (Connectionless)

하지만 이는 많은 단점을 갖고 있습니다.

- 수십, 수백개의 데이터를 교환할 때 굉장히 비효율적
- 연결을 맺고 끊는 것은 TCP 통신 과정에서 가장 많은 비용이 소비되는 작업

따라서 keep-alive가 등장했습니다!

<br>

### Keep-alive 설정

```
  Connection: Keep-Alive
  Keep-Alive:timeout=5, max=200
  //  연결을 keep-alive 상태로 유지하며, 하나의 연결당 5초 동안 유지합니다.
  //  최대 200개의 연결까지 허용한다는 의미를 가집니다.
```

<br>

### **장점**

- 하나의 연결로 여러 요청을 처리하기 때문에 효율적입니다.

### **단점**

- 연결이 그만큼 길어지기 때문에 동시간대 연결이 늘어납니다.
  - 연결을 다 써버리면 서버는 더 이상 연결을 받을 수 없습니다.
  - 따라서 keep-alive 설정의 max값으로 연결을 제한하며 사용합니다.

<br>

> 🤭 하지만 HTTP 2.0 에서는 아예 사라진 헤더입니다.

<br><br><br>

## ⑤. 상태 코드

서버가 응답으로 보내주는 응답 포맷의 시작줄에 상태 코드가 포함됩니다.

알아두면 좋을 상태 코드들만 첨부했습니다.

- **2XX 성공** : 서버가 요청을 성공적으로 처리했음
  - 200 : 서버가 요청을 제대로 처리했다.
- **3XX 리다이렉션** : 요청을 완료하기 위해 다른 페이지로 보내야 할 때
- **4XX 요청 오류** : 클라이언트 요청에 오류가 있음을 의미한다.
  - 400 : 헤더 포맷이 HTTP 규약에 맞지 않을 경우
  - 401 : 인증을 필요로 하는 요청인 경우
  - 403 : 서버가 요청 거부
  - 404 : 요청한 자원이 서버에 존재하지 않음
  - 405 : 요청에 지정한 방법을 찾을 수 없다.
  - 406 : 요청한 페이지를 콘텐츠 특성 때문에 응답할 수 없다.
  - 408 : 서버의 요청 대기가 시간 초과
  - 410 : 요청한 자원이 삭제되었음<br>
    404와 비슷하지만, 410은 과거에는 있었으나 지금 없는 자원 (ex) 삭제한 포스트
  - 411 : 유효한 콘텐츠 길이를 명시해줘야 함
- **5XX 서버 오류** : 서버에 문제가 있음을 나타낸다.

<br>

해당 코드를 확인해서 `현재 요청에 어떤 문제가 있는지, 요청이 어떻게 처리되었는지 파악`할 수 있습니다.

<br><br>

# ❸ HTTP 인증 방법

HTTP 프로토콜은 접근 제어와 인증을 위한 프래임워크를 기본적으로 제공합니다.

이는 **Basic Access Authentication**이라 합니다.

- 매 요청마다 HTTP 헤더에 아이디와 패스워드를 실어 보내면 서버에서 확인하고 인증하게 됩니다.
  ![Untitled 4](https://user-images.githubusercontent.com/72294509/156778377-79d60b96-f2ad-429a-a78a-8334a52c45e1.png)

1. HTTP 요청
2. 웹 서버는 401 Authorization Required(인증을 필요로 하는 요청)을 응답한다.
3. 브라우저는 ID, PW를 입력할 수 있는 인증 창을 띄운다.
4. 입력한 ID. PW를 HTTP 헤더에 담아 웹 서버로 보낸다.
5. 웹 서버가 ID, PW를 확인하고, 일치한다면 요청을 처리한다.

<br>

- 이는 웹 자원의 접근을 통제하기 위한 **최소한의 수단**만을 제공합니다.
- cookie, session identifier 이나 로그인 페이지 등의 준비 없이 순수하게 HTTP만을 사용해서 인증이 가능합니다.
- 암호화, 해쉬 등의 기술을 사용하지 않으므로 보안성이 낮습니다.
- 매 요청마다 ID, PW를 보내는 방식이기 때문에 캐쉬가 필요합니다.

<br><br><br>

# ❹ HTTP Method

HTTP Method는 클라이언트가 보낸 요청의 종류를 서버에게 알려주기 위해서 사용합니다.

- **GET** : 정보를 요청하기 위해서 사용한다. (SELECT)
- **POST** : 정보를 밀어넣기 위해서 사용한다. (INSERT)
- **PUT** : 정보를 업데이트하기 위해서 사용한다. (UPDATE)
- **DELETE** : 정보를 삭제하기 위해서 사용한다. (DELETE)
- **HEAD** : (HTTP) 헤더 정보만 요청한다. 해당 자원이 존재하는지, 혹은 서버에 문제가 없는지 확인하기 위해서 사용한다.
- **OPTIONS** : 웹 서버가 지원하는 메서드의 종류를 요청한다.
- **TRACE** : 클라이언트의 요청을 그대로 반환한다.

각 용도에 맞는 method가 있음에도 불구하고, 사실상 `GET`과 `POST` 만으로 모든 요청을 표현할 수 있습니다.

하지만 Restful API 서버의 경우에는 `GET, POST, DELETE, PUT`을 명시적으로 구분하므로, 알아둬야 합니다.

<br><br>

## ①. HTTP의 GET과 POST

### ▶ 공통점

- HTTP 프로토콜을 이용해서 서버에 무엇인가를 요청할 때 사용하는 방식입니다.

![Untitled](https://user-images.githubusercontent.com/72294509/156779826-8581a551-a328-47ed-93f8-47d534eb1f0d.png)

차이점을 알아보기 전, 먼저 `GET, POST`에 대해 정확히 알아보도록 하겠습니다.

<br><br>

### 1. GET

클라이언트에서 서버로 어떠한 **리소스로부터 정보를 요청**하기 위해 사용되는 메서드입니다.

> 예시 ) 게시판의 게시물을 조회할 때 쓰인다.

<br>

- URL 주소 끝에 파라미터로 포함되어 전송 (Query String)
- URL 끝에 “?”를 붙이고 `변수명1=값1&변수명2=값2...` 형식으로 이어 붙인다.

> 예시) `www.example.com/boardList?name1=value1&name2=value2`<br>
> name1과 name2라는 파라미터 명으로 각각 value1과 value2 파라미터 값을 전달받을 수 있다.

<br>

**GET 특징**

- 캐시가 가능합니다.<br>
  HTTP 헤더에서 `cache-control` 헤더를 통해 캐시 옵션을 지정할 수 있습니다.<br>
  POST 방식으로 요청해야 할 것을 보내는데 GET 방식을 사용할 경우, 기존에 캐싱되었던 데이터가 응답될 가능성이 존재합니다.
- 브라우저 히스토리에 남습니다.
- 길이 제한이 있습니다. <br>
  브라우저마다 길이 제한이 다릅니다.
- GET 요청은 파라미터에 정보가 노출되어 전송되므로 보안에 취약합니다.
- 중요한 정보가 아닌 단순 데이터를 요청할때만 사용한다.

<br>

> **캐싱이란**?<br>
> 한번 접근 후, 또 요청할 시 빠르게 접근하기 위해 레지스터에 데이터를 저장시켜 놓는 것

<br><br>

### 2. POST

클라이언트에서 서버로 리소스를 생성하거나 업데이트하기 위해 데이터를 보낼 때 사용되는 메서드입니다.

> 예시) 게시판에 게시글을 작성하는 작업 등

- 전송할 데이터를 HTTP 메세지 body 부분에 담아서 서버로 보냅니다.
  GET에서 URL의 파라미터로 보냈던 `name1=value1&name2=value2`가 body에 담겨 보내진다.

![Untitled 1](https://user-images.githubusercontent.com/72294509/156779821-78abb076-6f43-467a-bf70-5e881cc67071.png)

- 용량이 큰 데이터를 보낼 때 사용하거나, 데이터를 암호화하여 보안이 필요한 부분에서 많이 사용한다.
- HTML form을 통해 서버로 전송된다.

> 예시) `http://example.com/login`

<br>

- 요청 헤더에 `Content-Type`에 요청 데이터 타입을 표시해야 합니다.<br>
  표시하지 않을 시, 서버는 내용이나 URL에 포함된 확장자명 등으로 데이터 타입을 유추하며,<br>
  알 수 없는 경우에는 `application/octet-stream` 으로 요청을 처리합니다.

> **application/octet-stream**<br>
> 8비트 단위의 binary data라는 뜻
> 특별히 표현할 수 있는 프로그램이 존재하는 데이터의 경우 기본값으로 사용한다.
> 다른 데이터 타입의 경우, text, multipart, audio, video 등이 있다.

<br>

**POST 특징**

- 캐시되지 않습니다.
- 브라우저 히스토리에 남지 않습니다.
- 북마크되지 않습니다.
- 데이터 길이에 제한이 없습니다.

<br><br>

### ▶ 차이점

- **사용 목적**
  GET은 서버의 리소스에서 데이터를 요청할 때, POST는 서버의 리소스를 새로 생성하거나 업데이트 할 때 사용합니다.
  DB로 따지면 GET은 SELECT에 가깝고, POST는 Create에 가깝습니다.
- **요청에 body 유무**
  GET은 URL 파라미터에 요청하는 데이터를 담아 보내므로 HTTP 메세지에 body가 없습니다.
  POST는 body에 데이터를 담아 보내기 때문에 HTTP 메세지에 body가 존재합니다.
- **멱등성(Idempotent)**
  GET 요청은 멱등, POST 요청은 멱등이 아닙니다.

  <br>

> 멱등성
>
> - 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질
> - GET은 리소스를 ‘조회’하므로 여러번 요청하더라도 결과가 같다 → **멱등**
> - POST는 리소스를 새로 생성하거나 업데이트 할 때 사용된다. → **멱등이 아니다.** > <br>(POST 요청이 발생하면 서버의 저장된 내용이 변경될 수 있습니다.\_

<br>

![Untitled 2](https://user-images.githubusercontent.com/72294509/156779824-8e1563eb-f9d9-485f-aa33-11032458ea72.png)

---

### 출처

[HTTP MDN 문서](https://developer.mozilla.org/ko/docs/Web/HTTP/Authentication)

[HTTP Protocol Joinc Site](https://www.joinc.co.kr/w/Site/Network_Programing/AdvancedComm/HTTP)

[zerocho-HTTP란 무엇인가](https://www.zerocho.com/category/HTTP/post/5b344f3af94472001b17f2da)

[toma0912-HTTP란 무엇인가](https://toma0912.tistory.com/69)
