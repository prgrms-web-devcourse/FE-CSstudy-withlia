# SSL/TLS

## 목차

1. [무엇이 문제인가](#무엇이-문제인가)
2. [SSL TLS는 암호 프로토콜](#ssl-tls는-암호-프로토콜)
3. [SSL TLS의 역사](#ssl-tls의-역사)
4. [SSL TLS의 특징 및 기능](#ssl-tls의-특징-및-기능)
5. [SSL TLS의 동작 과정](#ssl-tls의-동작-과정)
6. [문제점](#문제점)
7. [출처](#출처)

## 무엇이 문제인가

1. 경유지를 거쳐가면서 데이터를 볼 수 있는 대상자가 너무 많다. (봤어도 봤는지도 모름)
2. 내가 통신하고 있는 대상이 실제 목적지가 아닐 수가 있다. (중간에 경유지가 본인이 목적지인척 속이고 통신이 가능)
3. 내가 보낸 데이터가 변질될 수도 있다. (받는 입장에서는 변경됐는는지 알 수 없다)

**이런 문제를 해결할 수 있는 통신 보안이 필요!**

## SSL TLS는 암호 프로토콜

- 통신 보안을 제공하기 위해 설계된 암호 규약.
- 응용 계층 데이터의 암호화.
- 암호화된 전송 계층의 복호화.
- 웹 브라우저와 웹 서버 사이의 안전한 보안 채널을 제공하기 위해 많이 사용됨.

## SSL TLS의 역사

### SSL(Secure Sockets Layer)

- 넷스케이프가 만든 통신 보안 프로토콜.
- SSL 1.0 (1994)
- SSL 2.0 (1995)
- SSL 3.0 (1996)

### TLS(Transport Layer Security)

- 국제 인터넷 표준화 기구에서 SSL 3.0을 바탕으로 만든 통신 보안 프로토콜.
- TLS 1.0 (1999)
- TLS 1.1 (2006)
- TLS 1.2 (2008)
- TLS 1.3 (2018)

**SSL 과 TLS는 통신 보안을 제공하는 프로토콜이고 같은 역할을 한다.(다른 버전 정도로 봐도 무방하다.)**

## SSL TLS의 특징 및 기능

### 특징

- 클라이언트/서버 기반의 프로토콜.
- 응용계층 및 전송계층 사이에 위치.
- 응용 프로그램(어플리케이션) 자체 구현 가능.
  - 대부분의 다른 보안 프로토콜(EAP,IPsec 등)은 운영체제 등에 밀접하게 관련됨.
- 프로토콜
  - TCP/UDP
  - DTLS(Datagram Transport Layer Security) : UDP 상에서도 가능한 버전.
- 포트
  - Application마다 다름. HTTPS(443)
- 인증 구조
  - X.509에서 규정된 **공개키 인증서 교환**에 의해 상대방에 대한 인증 수행
- 키 교환 방식(협상해서 선택)
  - Null, RSA 공개 키 교환, Anonymous Diffie-Hellman 키 교환, Ephermeral Diffie-Hellman 키 교환, Fixed Diffie-Hellman 키 교환, Fortezza
- 대칭키 암호화 방식 (협상해서 선택)
  - RC2 (40), RC4 (40), RC4 (128), DES, Triple DES, IDEA 등
- 해쉬 알고리즘 (협상 선택 가능)
  - Null, MD5, SHA-1

### 기능

- 상호 인증.
  - 공개키 인증서를 이용하여 서버,클라이언트의 상호 인증.
- 메세지 인증 (메세지 무결성).
  - 메세지 인증 코드 HMAC에 의한 메세지 무결성 제공.
- 암호화용 세션 키 생성(대칭 키 합의)을 위한 키 교환.
- 생성된 공유 비밀키에 의해 암호화된 종단간 안전한 연결 통로 제공.

## SSL TLS의 동작 과정

- 3단계로 진행.
- handshake -> 세션 -> 세션 종료
- 공개키와 대칭키를 혼합해서 사용.
  - 공개키로만 사용하면 컴퓨터자원소모가 매우 큼.
  - 실제 데티어를 대칭키로 암호화.
  - 대칭키를 만들 때 공개키 사용.

### 1. handshake

- 클라이언트가 서버에 접속.
  - Client Hello
  - 보내는 데이터들
    - 클라이언트 측에서 생성한 랜덤 데이터
    - 클라이언트가 지원하는 암호화 방식들
    - 세션 id: 이미 핸드셰이킹을 했다면 기존의 세션을 재활용하기 위해
- 서버가 Client Hello에 대한 응답으로 Serve Hello
  - 보내는 데이터들
    - 서버 측에서 생성한 랜덤 데이터
    - 서버가 선택한 클라이언트의 암호화 방식
      - 암호화 방식 협상의 종료.
      - 이 암호화 방식을 이용해서 정보를 교환한다.
    - 인증서
- 클라이언트가 서버에서 받은 인증서 확인.
  - 브라우저의 내장된 CA의 공개키로 인증서를 복호화. 성공하면 CA의 개인키로 암호화 된거니 믿을 수 있음.
  - 인증서를 복호화 함으로써 서버의 공개키 획득.
  - `pre master secret` 값 생성.
    - 클라이언트가 생성한 랜덤 데이터 + 서버가 생성한 랜덤 데이터를 활용해서 만든다.
    - 대칭키이기 떄문에 제 3자에게 절대 노출되면 안된다.
    - 서버의 공개키를 사용해서 전달하자.
- 서버는 자신의 개인키로 복호화해서 `pre master secret` 값 획득.
- 서버와 클라이언트는 `pre master secret` 값을 일련의 과정으로 `master secret`으로 만들고 이걸로 `session key` 생성.
  - 데이터 전송 단계에서 `session key`를 대칭키로 활용.
- handshake의 종료를 서로에 알려주면서 끝낸다.

### 2. 세션

- 실제로 서버와 클라이언트가 데이터를 주고 받는 단계.
- `session key`를 대칭키로 활용해서 암호화 복호화를 한다.

### 3. 세션 종료

- 데이터 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알림.
- 통신에서 사용한 세션키 폐지.
- 혹시나 세션키가 노출되서 해독이 된다고 해도 해당 세션키는 이미 폐지 됐기 때문에 의마가 없다.
  - 세션의 수립과 종료는 매우 빠르게 진행된다.

## 문제점

- 제대로 확인되지 않은 인증서를 발급한다면 더 이상 그 인증서를 신뢰할 수가 없음.
  - 도메인 소유자를 확인하는 방식의 Domain Validation 인증서를 발급. 누구나 발급 받는다.
  - 이러한 문제를 해결하기 위해 나온 것이 `EV-SSL`
  - `EV-SSL`은 공신력 있는 인증 기관에서 더욱 엄격한 심사 기준으로 발급한 Extended Validation 인증서를 사용하여 보안을 강화한 프로토콜.
- TLS는 망연결에서의 보안을 책임지고 있으므로, 연결된 단말기가 해킹당한 경우라면 아무리 TLS를 써도 무용지물.
  - 연결망의 안전성과 노드의 안전성은 별개.
- 서버나 클라이언트나 평문 통신에 비해 부하가 크다.
  - 프론트엔드단 웹을 대상으로 DDoS라도 시도할 경우 암호화 과정 때문에 HTTPS를 사용하지 않은 웹 사이트보다 더 빨리 서버가 죽을 수도 있음.
- TLS는 TCP 프로토콜을 이용하므로 성능상의 불이익도 존재.
  - UDP 기반의 보안 소켓인 DTLS가 이를 보완.

## 출처

- [위키백과 전송계층 보안](https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EA%B3%84%EC%B8%B5_%EB%B3%B4%EC%95%88#cite_note-3)
- [정보통신기술용어](http://www.ktword.co.kr/test/view/view.php?m_temp1=1957)
- [10분 테코톡 에단의 TLS](https://www.youtube.com/watch?v=EPcQqkqqouk)
- [생활코딩 ssl 통신과정](https://youtu.be/8R0FUF_t_zk)
- [나무위키 TLS](https://namu.wiki/w/TLS)
